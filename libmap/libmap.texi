\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename libmap.info
@settitle libmap
@setchapternewpage off
@c %**end of header
@synindex tp vr

@include version.texi

@ifinfo
@format
START-INFO-DIR-ENTRY
* libmap: (libmap).             Associative arrays
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@ifinfo
This file documents libmap @value{VERSION}

Copyright 1996 Dieter Baron

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph


@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo


@titlepage
@title libmap -- A Library for Associative Arrays
@subtitle For version @value{VERSION}, @value{UPDATED}
@author Dieter Baron
@c copyright page
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1996 Dieter Baron
@sp 2
This is a draft edition of the libmap documentation,@*
and is consistent with libmap @value{VERSION}.@*
@sp 2
@ignore
Published by the Free Software Foundation @*
59 Template Place - Suite 330, @*
Boston, MA 02111-1307 USA @*

@end ignore
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end titlepage

@ifinfo
@c ================================================================
@node Top, Introduction, (dir), (dir)
@comment  node-name,  next,  previous,  up
@top libmap

This file documents libmap, a library for associative arrays.  This
edition documents version @value{VERSION}.

libmap is a library that provides highly customizable associative
arrays, implemented as hash tables with external linking.

@menu
* Introduction::	Design Philosophy of libmap
* Helper::              Helper Functions
* Creating::            Creating and Destroying Maps
* Manipulating::        Manipulating Maps
* Iterating::           Iterating Through Maps
* Configuration::       Configurability and Default Values

* Index::
* Index of Functions::
* Index of Variables and Types::
@end menu
@end ifinfo

@c ================================================================
@node Introduction
@chapter Introduction
@cindex Introduction
@cindex map
@cindex hash table

Associative arrays (also called maps) are arrays whose indices, called
keys, are not natural numbers.  Most often, they are strings.

One way to implement associative arrays is to use hash tables: key/value
pairs are stored in an ordinary array, at the index specified by the
key's hash, which acts like a fingerprint.  This is both easy to
implement and efficient, if the function used to compute the hash value
is fast and rarely generates the same value for different keys.

There are different ways to handle collitions (two different keys with
the same hash value); one is to use linked lists as array elements, and
to store the key/value pairs in these lists (one for each hash value).
This method is not the fastest, but does not pose an arbitrary limit on
the size of the associative array.

Still, to get good performance, the size of the hash table should be
about 5 times as large as the expected number of entries (to avoid
collisions), but space can be traded off for time.

For a thorough discussion of hash tables, see @cite{The Art of Computer
Programming, Vol. III: Searching and Sorting}, by Donald E. Knuth.


@c ================================================================
@node Helper
@chapter Helper Functions
@findex helper function

The functions used to compute hash values from keys and test keys on
equality depend on the type of keys used.  To keep libmap general, such
functions can be provided by the application, altough reasonable default
functions are provided for the most common case: strings.

Also, a handfull of housekeeping functions can be provided by the
application.  These functiosn are collectively called helper functions,
and can be specified per map.

@deftp {Data Type} map
This is the type used to hold a map; a pointer to @code{map} is the first
parameter of most functions in this library, specifying the map to
operate on.

It also holds pointers to the helper functions used by this map.
@end deftp

The helper functions are:

@deftypefn {Helper Function} int equal (void *@var{key1}, void *@var{key2})
Used to compare keys for equality.  It is called with two keys and is
expected to 
@c XXX: not neccecarily 
@end deftypefn

@deftypefn {Helper Function} int hash (void *@var{key})
@end deftypefn

@deftypefn {Helper Function} {void *} cpykey (void *@var{key})
@end deftypefn

@deftypefn {Helper Function} void delkey (void *@var{key})
@end deftypefn

@deftypefn {Helper Function} void delval (void *@var{value})
@end deftypefn


@c ================================================================
@node Creating
@chapter Creating and Destroying Maps
@cindex creating
@cindex destroying

@deftypefun {map *} new_map (int @var{size})
The @code{new_map} function creates a new map of @var{size}, or
@code{map_def_size} if @var{size} is 0.  All helper functions are set to
their default values.

@code{new_map} returns the newly created map, or a null pointer if
creation fails.
@end deftypefun

@deftypefun {map *} new_map2 (int @var{size}, int (*@var{equal})(), int (*@var{hash})(), void *(*@var{cpykey})(), void (*@var{delkey})(), void (*@var{delval})())
The @code{new_map2} function is much like @code{map_new}, except that
all helper functions are given as arguments.  If any of them is a null
pointer, the corresponding default value is taken.

@code{new_map2} returns the newly created map, or a null pointer if
creation fails.
@end deftypefun

@deftypefun void free_map (map *@var{m}, int @var{delvaluep})
The function @code{free_map} deletes map @var{m} and frees all the
storage used by it.

If @var{delvaluep} is non-zero, the values stored in the
map are deleted by the @code{delval} helper function.
@end deftypefun


@c ================================================================
@node Manipulating
@chapter Manipulating Maps
@cindex manipulating

@deftypefun {void *} map_lookup (map *@var{m}, void *@var{key})
@end deftypefun

@deftypefun {void **} map_insert (map *@var{m}, void *@var{key})
@end deftypefun

@deftypefun void map_delete (map *@var{m}, void *@var{key}, int @var{delvaluep})
@end deftypefun


@c ================================================================
@node Iterating
@chapter Iterating Through Maps
@cindex iterating

@deftypefun {map_iter *} map_start (map *@var{m})
@end deftypefun

@deftypefun int map_next (map_iter *@var{iteratior}, void **@var{key}, void **@var{value})
@end deftypefun

@deftypefun void map_stop (map_iter *@var{iterator})
@end deftypefun


@c ================================================================
@node Configuration
@chapter Configurability and Default Values


@iftex
@page
@end iftex
@c ================================================================
@node Index
@unnumbered Index

@printindex cp

@node Index of Functions
@unnumbered Index of Functions

@printindex fn

@node Index of Variables and Types
@unnumbered Index of Variables and Types

@printindex vr

@contents
@bye
